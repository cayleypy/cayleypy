# CaleyPy

AI-based libarary to work with google-size graphs.
Supporting:  Cayley graphs, Schreier coset graphs, more to be added.


## Overview

Exteremely large graphs (e.g. google size) cannot be approached in a usual way,
it is impossible neither to create, neither to store them by standard methods.

Typically such graphs arise as state-transition graphs.
For chess, Go or any other games - nodes of the graphs are positions, edges correspond to moves between them.
For Rubik's cube - nodes are configurations, edges corresponds to configurations different by single moves. 

The most simple and clear examples of such graphs - are [Caley graphs](https://en.wikipedia.org/wiki/Cayley_graph) in mathematics.
(and [Schreier coset graphs](https://en.wikipedia.org/wiki/Schreier_coset_graph) ). 
Initial developments will focus on these graphs, supporting other types later. 

We plan to support:

* ML/RL methods for pathfinding 
* Estimation of diameters and growths
* Embeddings
* Efficient BFS for small subgraphs
* Efficient random walks generation
* Efficient Beam Search 
* Hamiltionan paths finding
* Efficient computing on CPU, GPU, TPU (with JAX), usable on Kaggle.
* Etc. 

Mathematical applications: 
* Estimation of diameters and growths
* Approximation of the word metrics and diffusion distnace
* Estimation of the mixing time for random walks of different types 
* BFS from given state (growth function, adjacency matrix, last layers).
* Library of graphs and generators (LRX, TopSpin, Rubik Cubes, wreath, globe etc.,
  see [here](https://www.kaggle.com/code/ivankolt/generation-of-incidence-mtx-pancake)).
* Library of datasets with solutions to some problems (e.g. growth functions like
  [here](https://www.kaggle.com/code/fedimser/bfs-for-binary-string-permutations)).

## Usage

See this demo [Kaggle notebook](https://www.kaggle.com/code/fedimser/cayleypy-demo) for examples
on how this library can be used.

## Development

To start development, run:

```
git clone https://github.com/cayleypy/cayleypy.git
cd cayleypy
pip install -r requirements.txt
pip install -r requirements-dev.txt
```

To run only quick tests:

```
FAST=1 pytest
```

Before commiting, run these checks:

```
./lint.sh
pytest 
```

To check coverage, run:

```
coverage run -m pytest && coverage html
```

### Formatting

This repository uses the [Black formatter](https://github.com/psf/black).
If you are getting error saying that some files "would be reformatted", you need to format
your code using Black. There are few convenient ways to do that:
* From command line: run `black .` 
* In PyCharm: go to Setting>Tools>Black, and check "Use Black formatter": "On code reformat" 
    (then it will run on Ctrl+Alt+L), or "On save", or both.
* In Visual Studio code: install the
    [Black Formatter extension](https://marketplace.visualstudio.com/items?itemName=ms-python.black-formatter),
    then use Ctrl+Shift+I to format code. 
    If you are  asked to configure default formatter, pick the Black formatter.

## How to add a new Cayley graph

Cayley graphs must be defined by a function that returns `CayleyGraphDef`. 
First, you need to decide where in the library to put it:
* If it's a graph for a physical puzzle, create a separate file in `cayleypy/puzzles`.
* If it's a graph generated by permutations, the function should be added to  
    `PermutationGroups` in `cayleypy/graphs_lib.py`, annotated as `@staticmethod`.
* If it's a new type of graph, check with @fedimser where to put it.

Do not add new graphs to `prepare_graph`! We want new graphs to be added in different 
places to avoid merge conflicts.

Then, you need to define your graph. Definition consists of the following:
* Generators.
* Generator names (optional).
* Central state (optional, defaults to neutral element in the group, e.g. 
    identity permutation).

When you are ready, do the following:
1. Create a new branch in this repository (not a fork).
2. Add your function where you decided. See how other graphs are defined and follow that as an example.
3. Add a test that creates an instance of your graph for small size and checks something about it 
     (at least check number of generators).
4. Create a pull request. Include some references to graph definition in PR description.

## Credits

The idea of the project - Alexander Chervov - see https://arxiv.org/abs/2502.18663, 
https://arxiv.org/abs/2502.13266, discussion group https://t.me/sberlogasci/1,
Early ideas and prototypes appeared during Kaggle challenge Santa 2023:
Prototype: https://www.kaggle.com/code/alexandervc/santa23-globe26-modeling5,
Description: https://www.kaggle.com/competitions/santa-2023/discussion/466399, 
https://www.kaggle.com/competitions/santa-2023/discussion/472594. 

The initial code developments can be found at Kaggle dataset:
https://www.kaggle.com/datasets/alexandervc/growth-in-finite-groups (see paper https://arxiv.org/abs/2502.13266 )
Other developments can be found at:
https://www.kaggle.com/competitions/lrx-oeis-a-186783-brainstorm-math-conjecture/code,
https://www.kaggle.com/datasets/alexandervc/cayleypy-development-3-growth-computations,
see also beam-search part: [ Cayleypy (Ivan Koltsov) ](https://github.com/iKolt/cayleypy),
Rubik's cube part: [Piligrim (Kirill Khoruzhii)](https://github.com/k1242).

Also, code from the following Kaggle notebooks was used:

* https://www.kaggle.com/code/ivankolt/generation-of-incidence-mtx-pancake (advanced BFS).
* https://www.kaggle.com/code/avm888/cayleypy-growth-function.
* https://www.kaggle.com/code/avm888/jax-version-cayleypy (how to use JAX).
* https://www.kaggle.com/code/fedimser/bfs-for-binary-string-permutations (bit operations).
* https://www.kaggle.com/code/ivankolt/lrx-4bit-uint64?scriptVersionId=221435319 (fast BFS)
