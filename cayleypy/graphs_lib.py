"""Library of pre-defined graphs."""
from cayleypy import CayleyGraph
import collections
from cayleypy.permutation_utils import compose_permutations, apply_permutation, inverse_permutation
from puzzles.cube import get_cube_generators

def _create_coxeter_generators(n: int) -> list[list[int]]:
    gens = []
    for k in range(n - 1):
        perm = list(range(n))
        perm[k], perm[k + 1] = perm[k + 1], perm[k]
        gens.append(perm)
    return gens


def help_cyclic(start_pos: int, finish_pos: int, N: int) -> list[int]:
    lst = []
    for i in range(start_pos):
        lst.append(i)
    for i in range(start_pos, finish_pos+1):
        lst.append((i+1) if i != finish_pos else start_pos)
    for i in range(finish_pos+1, N):
        lst.append(i)
    return lst


def globe_gens(A: int, B: int) -> Dict[str, list[int]]:
    gens = {}
    x_count = 2 * B
    y_count = A + 1
    N = 2 * (A + 1) * B
    for r_count in range(y_count):
        gens[f'r{r_count}'] = help_cyclic(r_count * x_count, (r_count + 1) * x_count - 1, N)

    total_A = y_count - 1
    for f_count in range(x_count):
        lst = list(range(N))

        for i in range(y_count // 2):
            block1 = []
            block2 = []
            for k in range(B):
                idx1 = i * x_count + (f_count + k) % x_count
                block1.append(idx1)
                idx2 = (total_A - i) * x_count + (f_count + k) % x_count
                block2.append(idx2)
            for k in range(B):
                idx1 = block1[k]
                idx2 = block2[B - 1 - k]
                lst[idx1], lst[idx2] = lst[idx2], lst[idx1]
        gens[f'f{f_count}'] = lst

    return gens

def full_set_of_perm_cube(cube_size: int) -> Dict[str, list[int]]:
    original_dict = generate_cube_permutations_oneline(cube_size)
    new_dict = {}
    for key, value in original_dict.items():
        new_dict[key] = list(map(int, value.split()))
        inv_key = key + '_inv'
        new_dict[inv_key] = inverse_permutation(list(map(int, value.split())))
    return new_dict

def full_set_of_perm_globe(A: int, B: int) -> Dict[str, list[int]]:
    original_dict = globe_gens(A, B)
    new_dict = {}
    for key, value in original_dict.items():
        new_dict[key] = value
        if 'r' in key:
            inv_key = key + '_inv'
            new_dict[inv_key] = inverse_permutation(value)
    return new_dict
    

def prepare_graph(name: str, **kwargs) -> CayleyGraph:
    """Returns pre-defined Cayley or Schreier coset graph.

    Supported graphs:
      * "all_transpositions" - Cayley graph for S_n (n>=2), generated by all n(n-1)/2 transpositions.
      * "pancake" - Cayley graph for S_n (n>=2), generated by reverses of all prefixes. It has n-1 generators denoted
          R1,R2..R(n-1), where Ri is reverse of elements 0,1..i. See https://en.wikipedia.org/wiki/Pancake_graph.
      * "burnt_pancake" - Cayley graph generated by reverses of all signed prefixes. Actually is a graph for
         S_2n (n>=1) representing a graph for n pancakes, where i-th element represents bottom side of i-th pancake,
         and (n+i)-th element represents top side of i-th pancake. The graph has n generators denoted R1,R2..R(n),
         where Ri is reverse of elements 0,1..i,n,n+1..n+i.
      * "full_reversals" - Cayley graph for S_n (n>=2), generated by reverses of all possible substrings.
          It has n(n-1)/2 generators.
      * "lrx" - Cayley graph for S_n (n>=3), generated by: shift left, shift right, swap first two elements.
      * "top_spin" - Cayley graph for S_n (n>=4), generated by: shift left, shift right, reverse first four elements.
      * "cube_2/2/2_6gensQTM" - Schreier coset graph for 2x2x2 Rubik's cube with fixed back left upper corner and only
          quarter-turns allowed. There are 6 generators (front, right, down face - clockwise and counterclockwise).
      * "cube_2/2/2_9gensHTM" - same as above, but allowing half-turns (it has 9 generators).
      * "cube_3/3/3_12gensQTM" - Schreier coset graph for 3x3x3 Rubik's cube with fixed central pieces and only
          quarter-turns allowed. There are 12 generators (clockwise and counterclockwise rotation for each face).
      * "cube_3/3/3_18gensHTM" - same as above, but allowing half-turns (it has 18 generators).
      * "coxeter" - Cayley graph for S_n (n>=2), generated by adjacent transpositions (Coxeter generators).
          It has n-1 generators: (0,1), (1,2), ..., (n-2,n-1).
      * "cube_n/n/n_gensQSTM" - QSTM(short for Quarter Slice Turn Metric),
          is a move count metric for the 3x3x3 in which any clockwise or counterclockwise 90-degree turn of any layer counts as one turn,
          and rotations do not count as moves.
      * "globeA/B" - Globe puzzle group, A + 1 cycle and 2B order 2 generators

    :param name: name of pre-defined graph.
    :param n: parameter (if applicable).
    :return: requested graph as `CayleyGraph`.
    """
    PARAM_REQUIREMENTS = {
        "all_transpositions": ["n"],
        "pancake": ["n"],
        "burnt_pancake": ["n"],
        "full_reversals": ["n"],
        "lrx": ["n"],
        "top_spin": ["n"],
        "coxeter": ["n"],
        "cube_n/n/n_gensQSTM": ["n"],
        "globeA/B": ["A", "B"],
        
    }
    required_params = PARAM_REQUIREMENTS.get(name, [])
    for param in required_params:
        if param not in kwargs:
            raise ValueError(f"Parameter '{param}' required for graph type '{name}'")
    params = {k: v for k, v in kwargs.items() if k in required_params}
    
    if name == "all_transpositions":
        n = params['n']
        assert n >= 2
        generators = []
        generator_names = []
        for i in range(n):
            for j in range(i + 1, n):
                perm = list(range(n))
                perm[i], perm[j] = j, i
                generators.append(perm)
                generator_names.append(f"({i},{j})")
        return CayleyGraph(generators, dest=list(range(n)), generator_names=generator_names)
    elif name == "burnt_pancake":
        n = params['n']
        assert n >= 1
        generators = []
        generator_names = []
        for prefix_len in range(0, n):
            perm = []
            perm += list(range(n+prefix_len, n-1, -1))
            perm += list(range(prefix_len+1, n, 1))
            perm += list(range(prefix_len, -1, -1))
            perm += list(range(n+prefix_len+1, 2*n, 1))
            generators.append(perm)
            generator_names.append("R" + str(prefix_len+1))
        return CayleyGraph(generators, dest=list(range(2*n)), generator_names=generator_names)
    elif name == "pancake":
        n = params['n']
        assert n >= 2
        generators = []
        generator_names = []
        for prefix_len in range(2, n + 1):
            perm = list(range(prefix_len - 1, -1, -1)) + list(range(prefix_len, n))
            generators.append(perm)
            generator_names.append("R" + str(prefix_len - 1))
        return CayleyGraph(generators, dest=list(range(n)), generator_names=generator_names)
    elif name == "burnt_pancake":
        assert n >= 1
        generators = []
        generator_names = []
        for prefix_len in range(0, n):
            perm = []
            perm += list(range(n+prefix_len, n-1, -1))
            perm += list(range(prefix_len+1, n, 1))
            perm += list(range(prefix_len, -1, -1))
            perm += list(range(n+prefix_len+1, 2*n, 1))
            generators.append(perm)
            generator_names.append("R" + str(prefix_len+1))
        return CayleyGraph(generators, dest=list(range(2*n)), generator_names=generator_names)
    elif name == "full_reversals":
        n = params['n']
        assert n >= 2
        generators = []
        generator_names = []
        for i in range(n):
            for j in range(i + 1, n):
                perm = list(range(i)) + list(range(j, i - 1, -1)) + list(range(j + 1, n))
                generators.append(perm)
                generator_names.append(f"R[{i}..{j}]")
        return CayleyGraph(generators, dest=list(range(n)), generator_names=generator_names)
    elif name == "lrx":
        n = params['n']
        assert n >= 3
        generators = [list(range(1, n)) + [0], [n - 1] + list(range(0, n - 1)), [1, 0] + list(range(2, n))]
        generator_names = ["L", "R", "X"]
        return CayleyGraph(generators, dest=list(range(n)), generator_names=generator_names)
    elif name == "top_spin":
        n = params['n']
        assert n >= 4
        generators = [list(range(1, n)) + [0], [n - 1] + list(range(0, n - 1)), [3, 2, 1, 0] + list(range(4, n))]
        return CayleyGraph(generators, dest=list(range(n)))
    elif name == "cube_2/2/2_6gensQTM":
        dict_of_gens = get_cube_generators(2, "QTM")
        generator_names = list(dict_of_gens.keys())
        generators = [dict_of_gens[k] for k in generator_names]
        initial_state = [color for color in range(6) for _ in range(4)]
        return CayleyGraph(generators, dest=initial_state, generator_names=generator_names)
    elif name == "cube_2/2/2_9gensHTM":
        dict_of_gens = get_cube_generators(2, "HTM")
        generator_names = list(dict_of_gens.keys())
        generators = [dict_of_gens[k] for k in generator_names]
        initial_state = [color for color in range(6) for _ in range(4)]
        return CayleyGraph(generators, dest=initial_state, generator_names=generator_names)
    elif name == "cube_3/3/3_12gensQTM":
        dict_of_gens = get_cube_generators(3, "QTM")
        generator_names = list(dict_of_gens.keys())
        generators = [dict_of_gens[k] for k in generator_names]
        initial_state = [color for color in range(6) for _ in range(9)]
        return CayleyGraph(generators, dest=initial_state, generator_names=generator_names)
    elif name == "cube_3/3/3_18gensHTM":
        dict_of_gens = get_cube_generators(3, "HTM")
        generator_names = list(dict_of_gens.keys())
        generators = [dict_of_gens[k] for k in generator_names]
        initial_state = [color for color in range(6) for _ in range(9)]
        return CayleyGraph(generators, dest=initial_state, generator_names=generator_names)
    elif name == "coxeter":
        n = params['n']
        assert n >= 2
        generators = _create_coxeter_generators(n)
        generator_names = [f"({i},{i+1})" for i in range(n-1)]
        initial_state = list(range(n))
        return CayleyGraph(generators, dest=initial_state, generator_names=generator_names)
    elif name == "cube_n/n/n_gensQSTM":
        n = params['n']
        assert n >= 2
        dict_of_gens = get_cube_generators(n, "QSTM")
        generator_names = list(dict_of_gens.keys())
        generators = [dict_of_gens[k] for k in generator_names]
        return CayleyGraph(generators, dest=initial_state, generator_names=generator_names)
    elif name == "globeA/B":
        A = params['A']
        B = params['B']
        assert A >= 1
        assert B >= 1
        generators = list(full_set_of_perm_globe(A, B).values())
        generator_names = list(full_set_of_perm_globe(A, B).keys())
        initial_state = list(range(2*B*(A+1)))
        return CayleyGraph(generators, dest=initial_state, generator_names=generator_names)
    else:
        raise ValueError(f"Unknown generator set: {name}")
